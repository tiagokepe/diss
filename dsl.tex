\chapter{Domain-Specific Language} % (fold)
\label{cha:dsl}

In this chapter we present some fundamentals of Domain-Specific Language(DSL) and
one language as interface with the users and self-tuning.

A \textit{DSL} is way to approach of some specific
context through appropriate notations and abstractions~\cite{deursen:2000}. DSL
transforms a particular problem domain into a context intelligible for expert
users that can work in a familiar environment.

Problem domain is a crucial term of DSL that requires prior background of the
developers in the specific context. The developers must be expert in the domain
in order to develop a DSL that cover the features required for the users. There are
a lot of examples of DSLs in differents domains, \textbf{(LEX, YACC, Make, SQL,
HTML, CSS, LATEX, etc.)} are classical examples of DSLs~\cite{bentley:1986}.

DLSs normally focus in specific domain, containing notations and specific abstractions.
Also it is \textit{small} and \textit{declarative} languages. But, a
DSL can be extended to differents domains, such DSL is called general-purpose
language (GPL), because its expressiveness power is not restrict to
an exclusive domain, examples of such DSLs are \textbf{Cobol and Fortran}, which
could be viewed as languages focused on the domain of business and scientific
programming  ~\cite{deursen:2000}.

DSL are used in several big areas, such \textbf{Software Engineering}, 
\textbf{Artificial Intelligence}, \textbf{Computers Architecture}(in this area a
good exemple is VHSIC Hardware Description Language (VHDL), where VHSIC mean 
{\bf V}ery {\bf H}igh {\bf S}peed {\bf I}ntegrated {\bf C}ircuits), \textbf{Database
Systems}(SQL, Datalog, QBE, Bloom), \textbf{Network}(where its
protocols are examples of DSLs), \textbf{Distribuited Systems}, \textbf{Multi-Media}
and among others. A current area that have been emerged recently is \textbf{Big Data}.
This area may be considered as a sub area of Database, but is has many
particularities that involve a mix features of Database and Distributed Systems.

\section{DSL Design Methodology}

The first step to create a new DSL is identifing the problem domain. Depending on
context is not so easy to abstract the complete knowledge of the domain, because
the developers must have a deep prior knowledge of the context, so considering all
variables and intrinsics aspects belonging to the domain. Furthermore, some times
the context can cover more than one domain, for example the GPLs. In other cases
the correct abstraction of the domain is fast and there is not margin for doubts
and equivocation. In both cases the foreknowledge of the developers is the factor
that more influences in good or bad DSLs resultants.

After identifying the problem domain the developer must abstract all relevant 
aspects from it. For example {\it VHDL}, it agroup semantic notations and operations
on logical circuit that allows to express logical components, bus, datapath and
control signals. With these four components we can describe any logical circuit
since a ALU(Arithmetic logic unit), register bank till one complex microprocessor. 

The next step is designing a DSL that expresses applications in the domain. DSL
will have limited concepts which are all focused on the specific domain. For
design the DLS is necessary to analyse the relationship between it and the existing
languages. According with~\cite{mernik:2005} there are some design patterns to
develop a DSL based on existing languages that is represented by figure ~\ref{fig:patterns}.

\begin{figure}[htbp]
        \centering
        \includegraphics[width=\columnwidth]{img/designPatterns.png}
        \caption{Design patterns - Figure extracted from~\cite{mernik:2005}.}\label{fig:patterns}
\end{figure}

In the implementation, a library with the semantic notations are built
together with a compiler that perfoms the lexical, syntactic and semantic analysis, 
after converting the DSL programs to sequence of library calls. Generally the library
and the compiler are built with support of the tools or framework developed
for this purpose. \textbf{Xtext}~\cite{xtext} and \textbf{Groovy}~\cite{groovyDSL, groovyDSLBook}
are examples of tools to develop DSLs.

\section{Context Transformation}
\label{sec:contextTrans}

Our context is focused on hadoop environment that have its own particularities. Thus
a context transformation is mandatory to implement the bacterionlogical algorithm
on such environment.

On hadoop there is huge set of configuration parameters, we called one specific 
parameters as \textbf{knob}. A job use several knobs that are one set of knobs. 
When sets of knobs gathered we have a population of knobs.

In the context tranformation, each component of genetic
context was translated to one component of hadoop environment. Like shown in the
figure~\ref{fig:transformation} we can realize that one gene was transformed to one knob,
one individual(that is a set of genes) was transformed to one set of knobs and
one individuals population was transformed to a population of knobs.

\begin{figure}[htbp]
        \centering
        \includegraphics[width=\columnwidth]{img/transformation.jpg}
        \caption{Context transformation.}\label{fig:transformation}
\end{figure}

An interesting characteristic of the tranformation is its bijection that one
component in the genetic domain is translated to one component in hadoop domain. Beyond
that the transformation has inversion property, i.e, all components in hadoop domain
can be translated to respective components in genetic domain. That properties
represent compatibility between both domains and somewhat a good representativeness.
\\
\\
\\
\\
\\
\\
\\
%-------------------------------------------------------------------------------
% Put here one formal teorem and a prof for the afirmation above. ^^^^^^^^^^^^^^
%-------------------------------------------------------------------------------
\section{DSL Proposal}

Our DSL proposal is based on the \textbf{Xtext}~\cite{xtext} framework. It requires
to define a grammar and rules for the specific domain. The base of the DLS is the
self-tuning using BA. So our effort aims to describe rules to represent all aspects
and components required for self-tunning.

Our domain has the following components:

\begin{itemize} 
    \item The job with its properties;
    \item The knobs;
    \item The knob with own type, minimum and maximum thresholds and its initial value.
\end{itemize}

Based on these componens we present one draft of our DSL proposal:

\singlespacing
\begin{listing}[H]
\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
DomainModel:
	job=Job;
	
Job:
	'Job' name=ID '{'
        setProperties+=Properties*
		setKnobs+=Knobs*
	'}'
;

Properties:
    'Properties' '{'
        properties+=Property
    '}'

Property:
    name=ID Value
;

Value: String;


Knobs:
	'knobs' '{'
		knobs+=Knob*
	'}' 
;

Knob:
	 name=ID Type
;

Type:
	IntType | FloatType | BoolType
;

IntType:
	'int' MinInt MaxInt '=' INT
;
MaxInt: INT;
MinInt: INT;

FloatType:
	'float' MinFloat MaxFloat '=' Float
;
MaxFloat: Float;
MinFloat: Float;

Float:
	INT*'.'INT*
;

BoolType:
	'boolean' '=' Boolean
;
Boolean:
	'true' | 'false' 
;

\end{minted}
\caption{Initial DSL proposal} 
\label{listing:dlsProposal}
\end{listing}

Let's explain all rules involving our grammar:
\begin{enumerate}
	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			DomainModel:
				job=Job;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The first rule in a grammar is always used as the entry or start rule.
		It says that the \textbf{DomainModel} contains one element \textbf{Job}
		assigned to a feature called \textit{job}.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			Job:
				'Job' name=ID '{'
                    setProperties+=Properties*
					setKnobs+=Knobs*
				'}'
			;	
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The rule \textbf{Job} starts with the definition of a keyword ({\it Job})
		followed by a name. Between 'braces' the job contains one arbitrary number
		(*) of \textbf{Properties} and \textbf{Knobs} which will be added (+=) to
        a feature called setProperties and setKnobs, respectively.

    \item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}

            Properties:
                'Properties' '{'
                    properties+=Property
                '}'
            ;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

        The rule {\bf Properties} starts with the definition of a keyword {\bf Properties}
		and between 'braces' contains one arbitrary number (*) of \textbf{Property}
		which will be added (+=) to a feature called properties.

    \item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}

            Property:
                name=ID Value
            ;

            Value: String;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

        These two rules are used to describe job properties, each property has an
        ID followed by its value. The value is an String.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			Knobs:
				'knobs' '{'
					knobs+=Knob*
				'}' 
			;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The rule \textbf{Knobs} starts with the definition of a keyword {\bf knobs}
		and between 'braces' contains one arbitrary number (*) of \textbf{Knob}
		which will be added (+=) to a feature called knobs.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			Knob:
				 name=ID Type
			;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The rule \textbf{Knob} contain one name followed by a \textbf{Type} with
		your peculiarities explained below.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			Type:
				IntType | FloatType | BoolType
			;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The rule \textbf{Type} can accept three type: integer, float or boolean,
		this three are all possibles types on hadoop parameters configuration.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			IntType:
				'int' MinInt MaxInt '=' INT
			;
			MaxInt: INT;
			MinInt: INT;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		These three rules are used for integer types, the rule \textbf{IntType}
		starts with the keyword {\bf int} followed by your respective minimum
		and maximum possibles values. In sequence there is the keyword {\bf '='}
		and the initial value for the knob.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			FloatType:
				'float' MinFloat MaxFloat '=' Float
			;
			MaxFloat: Float;
			MinFloat: Float;

			Float:
				INT*'.'INT*
			;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		These four rules are used for float types, the rule \textbf{FloatType} is
		similar the IntType rule, it starts with the keyword {\bf float} followed
		by your respective minimum and maximum possibles values. In sequence there
		is the key word {\bf '='}	and the initial float value for the knob. The rule
		{\bf FloatType} expresses the float format.

	\item
		\singlespacing
		\begin{listing}[H]
		\begin{minted}[mathescape,frame=lines,framesep=2mm,fontfamily=courier,fontsize=\scriptsize]{python}
			BoolType:
				'boolean' '=' Boolean
			;
			Boolean:
				'true' | 'false' 
			;
		\end{minted}
		\label{listing:modelRule}
		\end{listing}

		The last one rule {\bf BoolType} expresses the boolean type, it starts with
		the keyword {\bf boolean} followed by signal of \textbf{'='} and the initial
		boolean	value that can be {\bf true} or {\bf false}.

\end{enumerate}
